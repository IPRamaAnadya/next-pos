import { PayrollPeriod } from '../../domain/entities/PayrollPeriod';
import { PayrollDetail } from '../../domain/entities/PayrollDetail';
import { PayrollSetting } from '../../domain/entities/PayrollSetting';
import { Salary } from '../../domain/entities/Salary';
import { Attendance } from '../../domain/entities/Attendance';
import { 
  PayrollPeriodRepository,
  PayrollDetailRepository,
  PayrollSettingRepository,
  SalaryRepository
} from '../../domain/repositories/PayrollRepository';
import { AttendanceRepository } from '../interfaces/AttendanceRepository';
import { PayrollDomainService, PayrollCalculationParams } from '../../domain/services/PayrollDomainService';

export interface CreatePayrollPeriodData {
  tenantId: string;
  periodStart: Date;
  periodEnd: Date;
}

export interface UpdatePayrollPeriodData {
  periodStart?: Date;
  periodEnd?: Date;
}

export interface CreatePayrollDetailData {
  tenantId: string;
  payrollPeriodId: string;
  staffId: string;
  bonusAmount?: number;
  deductionsAmount?: number;
  manualOvertimeHours?: number;
  useActualWorkHours?: boolean;
}

export interface UpdatePayrollDetailData {
  bonusAmount?: number;
  deductionsAmount?: number;
  manualOvertimeHours?: number;
}

export interface PayrollSummaryQuery {
  tenantId: string;
  periodId?: string;
  isPaid?: boolean;
  startDate?: Date;
  endDate?: Date;
}

export interface BulkPayrollCalculationData {
  tenantId: string;
  payrollPeriodId: string;
  staffIds: string[];
  useActualWorkHours?: boolean;
  globalBonusAmount?: number;
  globalDeductionsAmount?: number;
}

export class PayrollUseCases {
  private static instance: PayrollUseCases;

  private constructor(
    private payrollPeriodRepository: PayrollPeriodRepository,
    private payrollDetailRepository: PayrollDetailRepository,
    private payrollSettingRepository: PayrollSettingRepository,
    private salaryRepository: SalaryRepository,
    private attendanceRepository: AttendanceRepository
  ) {}

  public static getInstance(
    payrollPeriodRepository: PayrollPeriodRepository,
    payrollDetailRepository: PayrollDetailRepository,
    payrollSettingRepository: PayrollSettingRepository,
    salaryRepository: SalaryRepository,
    attendanceRepository: AttendanceRepository
  ): PayrollUseCases {
    if (!PayrollUseCases.instance) {
      PayrollUseCases.instance = new PayrollUseCases(
        payrollPeriodRepository,
        payrollDetailRepository,
        payrollSettingRepository,
        salaryRepository,
        attendanceRepository
      );
    }
    return PayrollUseCases.instance;
  }

  // ==================== PAYROLL PERIOD OPERATIONS ====================

  async createPayrollPeriod(data: CreatePayrollPeriodData): Promise<PayrollPeriod> {
    // Check for overlapping periods
    const overlapping = await this.payrollPeriodRepository.findOverlapping(
      data.tenantId,
      data.periodStart,
      data.periodEnd
    );

    if (overlapping.length > 0) {
      throw new Error('Payroll period overlaps with existing period');
    }

    const period = PayrollPeriod.create(
      '', // ID will be generated by repository
      data.tenantId,
      data.periodStart,
      data.periodEnd
    );

    // Validate the period
    const validation = PayrollDomainService.validatePayrollPeriod(period);
    if (!validation.isValid) {
      throw new Error(`Invalid payroll period: ${validation.errors.join(', ')}`);
    }

    return await this.payrollPeriodRepository.create(period);
  }

  async getPayrollPeriod(id: string): Promise<PayrollPeriod | null> {
    return await this.payrollPeriodRepository.findById(id);
  }

  async getPayrollPeriodsByTenant(tenantId: string, includeFinalized: boolean = true): Promise<PayrollPeriod[]> {
    return await this.payrollPeriodRepository.findByTenant(tenantId, includeFinalized);
  }

  async getCurrentPayrollPeriod(tenantId: string): Promise<PayrollPeriod | null> {
    return await this.payrollPeriodRepository.findCurrent(tenantId);
  }

  async updatePayrollPeriod(id: string, data: UpdatePayrollPeriodData): Promise<PayrollPeriod> {
    const existingPeriod = await this.payrollPeriodRepository.findById(id);
    if (!existingPeriod) {
      throw new Error('Payroll period not found');
    }

    if (!existingPeriod.canBeModified()) {
      throw new Error('Cannot modify finalized payroll period');
    }

    // Check for overlapping periods if dates are being changed
    if (data.periodStart || data.periodEnd) {
      const newStart = data.periodStart ?? existingPeriod.periodStart;
      const newEnd = data.periodEnd ?? existingPeriod.periodEnd;
      
      const overlapping = await this.payrollPeriodRepository.findOverlapping(
        existingPeriod.tenantId,
        newStart,
        newEnd,
        id // Exclude current period from overlap check
      );

      if (overlapping.length > 0) {
        throw new Error('Updated payroll period would overlap with existing period');
      }
    }

    const updatedPeriod = PayrollPeriod.create(
      existingPeriod.id,
      existingPeriod.tenantId,
      data.periodStart ?? existingPeriod.periodStart,
      data.periodEnd ?? existingPeriod.periodEnd,
      existingPeriod.isFinalized,
      existingPeriod.createdAt,
      new Date()
    );

    return await this.payrollPeriodRepository.update(id, updatedPeriod);
  }

  async finalizePayrollPeriod(id: string): Promise<PayrollPeriod> {
    const period = await this.payrollPeriodRepository.findById(id);
    if (!period) {
      throw new Error('Payroll period not found');
    }

    if (!period.canBeFinalized()) {
      throw new Error('Payroll period cannot be finalized');
    }

    return await this.payrollPeriodRepository.finalize(id);
  }

  async deletePayrollPeriod(id: string): Promise<void> {
    const period = await this.payrollPeriodRepository.findById(id);
    if (!period) {
      throw new Error('Payroll period not found');
    }

    if (!period.canBeModified()) {
      throw new Error('Cannot delete finalized payroll period');
    }

    // Check if there are any payroll details
    const details = await this.payrollDetailRepository.findByPeriod(id);
    if (details.length > 0) {
      throw new Error('Cannot delete payroll period with existing payroll details');
    }

    await this.payrollPeriodRepository.delete(id);
  }

  // ==================== PAYROLL CALCULATION & DETAILS ====================

  async calculatePayrollForStaff(data: CreatePayrollDetailData): Promise<PayrollDetail> {
    // Get required data
    const [salary, payrollSetting, period] = await Promise.all([
      this.salaryRepository.findByStaff(data.staffId),
      this.payrollSettingRepository.findByTenant(data.tenantId),
      this.payrollPeriodRepository.findById(data.payrollPeriodId)
    ]);

    if (!salary) {
      throw new Error('Staff salary not found');
    }

    if (!payrollSetting) {
      throw new Error('Payroll settings not configured for tenant');
    }

    if (!period) {
      throw new Error('Payroll period not found');
    }

    // Check if calculation can be performed
    const canCalculate = PayrollDomainService.canCalculatePayroll(salary, payrollSetting, period);
    if (!canCalculate.canCalculate) {
      throw new Error(canCalculate.reason);
    }

    // Check if payroll detail already exists
    const existingDetail = await this.payrollDetailRepository.findByPeriodAndStaff(
      data.payrollPeriodId,
      data.staffId
    );

    if (existingDetail) {
      throw new Error('Payroll detail already exists for this staff and period');
    }

    // Get attendance data if needed
    let attendances: Attendance[] = [];
    if (data.useActualWorkHours) {
      attendances = await this.attendanceRepository.findByStaffAndDateRange(
        data.staffId,
        period.periodStart,
        period.periodEnd
      );
    }

    // Calculate payroll
    const calculationParams: PayrollCalculationParams = {
      salary,
      payrollSetting,
      attendances,
      bonusAmount: data.bonusAmount ?? 0,
      deductionsAmount: data.deductionsAmount ?? 0,
      manualOvertimeHours: data.manualOvertimeHours,
      useActualWorkHours: data.useActualWorkHours ?? false
    };

    const calculation = PayrollDomainService.calculatePayroll(calculationParams);

    // Create payroll detail
    const payrollDetail = PayrollDetail.create(
      '', // ID will be generated by repository
      data.tenantId,
      data.payrollPeriodId,
      data.staffId,
      calculation.basicSalaryAmount,
      calculation.fixedAllowanceAmount,
      calculation.overtimeHours,
      calculation.overtimePay,
      calculation.bonusAmount,
      calculation.deductionsAmount
    );

    return await this.payrollDetailRepository.create(payrollDetail);
  }

  async bulkCalculatePayroll(data: BulkPayrollCalculationData): Promise<PayrollDetail[]> {
    const [payrollSetting, period] = await Promise.all([
      this.payrollSettingRepository.findByTenant(data.tenantId),
      this.payrollPeriodRepository.findById(data.payrollPeriodId)
    ]);

    if (!payrollSetting) {
      throw new Error('Payroll settings not configured for tenant');
    }

    if (!period) {
      throw new Error('Payroll period not found');
    }

    const results: PayrollDetail[] = [];
    const errors: { staffId: string; error: string }[] = [];

    for (const staffId of data.staffIds) {
      try {
        const detail = await this.calculatePayrollForStaff({
          tenantId: data.tenantId,
          payrollPeriodId: data.payrollPeriodId,
          staffId,
          bonusAmount: data.globalBonusAmount,
          deductionsAmount: data.globalDeductionsAmount,
          useActualWorkHours: data.useActualWorkHours
        });
        results.push(detail);
      } catch (error) {
        errors.push({
          staffId,
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    }

    if (errors.length > 0) {
      throw new Error(`Bulk calculation completed with errors: ${JSON.stringify(errors)}`);
    }

    return results;
  }

  async getPayrollDetail(id: string): Promise<PayrollDetail | null> {
    return await this.payrollDetailRepository.findById(id);
  }

  async getPayrollDetailsByPeriod(payrollPeriodId: string): Promise<PayrollDetail[]> {
    return await this.payrollDetailRepository.findByPeriod(payrollPeriodId);
  }

  async getPayrollDetailsByStaff(staffId: string, includeUnpaid: boolean = true): Promise<PayrollDetail[]> {
    return await this.payrollDetailRepository.findByStaff(staffId, includeUnpaid);
  }

  async updatePayrollDetail(id: string, data: UpdatePayrollDetailData): Promise<PayrollDetail> {
    const existingDetail = await this.payrollDetailRepository.findById(id);
    if (!existingDetail) {
      throw new Error('Payroll detail not found');
    }

    if (!existingDetail.canBeModified()) {
      throw new Error('Cannot modify paid payroll detail');
    }

    // Get required data for recalculation
    const [salary, payrollSetting, period] = await Promise.all([
      this.salaryRepository.findByStaff(existingDetail.staffId),
      this.payrollSettingRepository.findByTenant(existingDetail.tenantId),
      this.payrollPeriodRepository.findById(existingDetail.payrollPeriodId)
    ]);

    if (!salary || !payrollSetting || !period) {
      throw new Error('Required data not found for payroll recalculation');
    }

    // Recalculate with new parameters
    const calculationParams: PayrollCalculationParams = {
      salary,
      payrollSetting,
      attendances: [], // For updates, we'll use the existing calculation logic
      bonusAmount: data.bonusAmount ?? existingDetail.bonusAmount,
      deductionsAmount: data.deductionsAmount ?? existingDetail.deductionsAmount,
      manualOvertimeHours: data.manualOvertimeHours ?? existingDetail.overtimeHours
    };

    const calculation = PayrollDomainService.calculatePayroll(calculationParams);

    const updatedDetail = PayrollDetail.create(
      existingDetail.id,
      existingDetail.tenantId,
      existingDetail.payrollPeriodId,
      existingDetail.staffId,
      calculation.basicSalaryAmount,
      calculation.fixedAllowanceAmount,
      calculation.overtimeHours,
      calculation.overtimePay,
      calculation.bonusAmount,
      calculation.deductionsAmount,
      existingDetail.isPaid,
      existingDetail.paidAt,
      existingDetail.createdAt,
      new Date()
    );

    return await this.payrollDetailRepository.update(id, updatedDetail);
  }

  async markPayrollAsPaid(id: string): Promise<PayrollDetail> {
    const detail = await this.payrollDetailRepository.findById(id);
    if (!detail) {
      throw new Error('Payroll detail not found');
    }

    if (!detail.canBePaid()) {
      throw new Error('Payroll detail cannot be marked as paid');
    }

    return await this.payrollDetailRepository.markAsPaid(id);
  }

  async bulkMarkPayrollAsPaid(ids: string[]): Promise<PayrollDetail[]> {
    // Validate all details can be paid
    const details = await Promise.all(
      ids.map(id => this.payrollDetailRepository.findById(id))
    );

    const invalidDetails = details.filter((detail, index) => 
      !detail || !detail.canBePaid()
    );

    if (invalidDetails.length > 0) {
      throw new Error('Some payroll details cannot be marked as paid');
    }

    return await this.payrollDetailRepository.bulkMarkAsPaid(ids);
  }

  // ==================== PAYROLL REPORTING & ANALYTICS ====================

  async getPayrollSummary(query: PayrollSummaryQuery): Promise<any> {
    let details: PayrollDetail[] = [];

    if (query.periodId) {
      details = await this.payrollDetailRepository.findByPeriod(query.periodId);
    } else if (query.startDate && query.endDate) {
      details = await this.payrollDetailRepository.findByDateRange(
        query.tenantId,
        query.startDate,
        query.endDate
      );
    } else {
      details = await this.payrollDetailRepository.findByTenant(query.tenantId, query.isPaid);
    }

    const summary = PayrollDomainService.generatePayrollSummary(details);

    return {
      ...summary,
      details: details.length <= 100 ? details : [], // Include details only for small datasets
      query
    };
  }

  async getUnpaidPayrolls(tenantId: string): Promise<PayrollDetail[]> {
    return await this.payrollDetailRepository.findUnpaidByTenant(tenantId);
  }

  // ==================== BACKWARD COMPATIBILITY METHODS ====================

  async findById(id: string, tenantId: string): Promise<PayrollDetail | null> {
    const detail = await this.payrollDetailRepository.findById(id);
    if (!detail || detail.tenantId !== tenantId) {
      return null;
    }
    return detail;
  }

  async findByPeriodAndStaff(payrollPeriodId: string, staffId: string, tenantId: string): Promise<PayrollDetail | null> {
    const detail = await this.payrollDetailRepository.findByPeriodAndStaff(payrollPeriodId, staffId);
    if (!detail || detail.tenantId !== tenantId) {
      return null;
    }
    return detail;
  }

  async findAll(tenantId: string, isPaid?: boolean): Promise<PayrollDetail[]> {
    return await this.payrollDetailRepository.findByTenant(tenantId, isPaid);
  }
}