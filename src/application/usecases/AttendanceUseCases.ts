import { AttendanceRepository } from '../interfaces/AttendanceRepository';
import { ShiftRepository } from '../interfaces/ShiftRepository';
import { Attendance } from '../../domain/entities/Attendance';
import { AttendanceDomainService } from '../../domain/services/AttendanceDomainService';
import { CreateAttendanceData, UpdateAttendanceData } from '../interfaces/dto/AttendanceDto';

export class AttendanceUseCases {
  constructor(
    private attendanceRepository: AttendanceRepository,
    private shiftRepository: ShiftRepository
  ) {}

  async createAttendance(data: CreateAttendanceData): Promise<Attendance> {
    // Validate shift exists if provided
    let shift = null;
    if (data.shiftId) {
      shift = await this.shiftRepository.findById(data.shiftId);
      if (!shift) {
        throw new Error('Shift not found');
      }
      
      // Validate shift belongs to the same tenant
      if (shift.tenantId !== data.tenantId) {
        throw new Error('Shift does not belong to this tenant');
      }
    }

    // Get existing attendances for validation
    const existingAttendances = await this.attendanceRepository.findByStaffAndDate(
      data.staffId,
      data.date
    );

    // Create attendance
    const attendanceData = AttendanceDomainService.createAttendanceWithShift(
      data.tenantId,
      data.staffId,
      data.date,
      data.shiftId,
      data.checkInTime,
      data.checkOutTime,
      data.isWeekend || false
    );

    // Create proper Attendance entity
    const attendance = new Attendance(
      '', // Will be generated by repository
      attendanceData.tenantId,
      attendanceData.staffId,
      attendanceData.date,
      attendanceData.checkInTime || null,
      attendanceData.checkOutTime || null,
      null, // totalHours - will be calculated
      attendanceData.isWeekend,
      new Date(), // createdAt
      new Date(), // updatedAt
      attendanceData.shiftId || null
    );

    // Validate attendance constraints
    AttendanceDomainService.validateAttendance(attendance, existingAttendances, shift ?? undefined);

    // Save to database
    const savedAttendance = await this.attendanceRepository.create(attendance);

    return savedAttendance;
  }

  async updateAttendance(id: string, data: UpdateAttendanceData): Promise<Attendance> {
    const existingAttendance = await this.attendanceRepository.findById(id);
    if (!existingAttendance) {
      throw new Error('Attendance not found');
    }

    // Validate shift if provided
    let shift = null;
    if (data.shiftId) {
      shift = await this.shiftRepository.findById(data.shiftId);
      if (!shift) {
        throw new Error('Shift not found');
      }
      
      if (shift.tenantId !== existingAttendance.tenantId) {
        throw new Error('Shift does not belong to this tenant');
      }
    }

    // Get existing attendances for validation (excluding current one)
    const existingAttendances = await this.attendanceRepository.findByStaffAndDate(
      existingAttendance.staffId,
      existingAttendance.date
    );
    const otherAttendances = existingAttendances.filter(a => a.id !== id);

    // Create updated attendance
    const updatedAttendance = new Attendance(
      existingAttendance.id,
      existingAttendance.tenantId,
      existingAttendance.staffId,
      data.date ?? existingAttendance.date,
      data.checkInTime ?? existingAttendance.checkInTime,
      data.checkOutTime ?? existingAttendance.checkOutTime,
      existingAttendance.totalHours, // Keep existing totalHours
      data.isWeekend ?? existingAttendance.isWeekend,
      existingAttendance.createdAt,
      new Date(),
      data.shiftId ?? existingAttendance.shiftId
    );

    // Validate updated attendance
    AttendanceDomainService.validateAttendance(updatedAttendance, otherAttendances, shift ?? undefined);

    // Save to database
    const savedAttendance = await this.attendanceRepository.update(id, updatedAttendance);

    return savedAttendance;
  }

  async getAttendanceById(id: string): Promise<Attendance | null> {
    return this.attendanceRepository.findById(id);
  }

  async getAttendancesByStaff(
    staffId: string,
    startDate?: Date,
    endDate?: Date
  ): Promise<Attendance[]> {
    return this.attendanceRepository.findByStaff(staffId, startDate, endDate);
  }

  async getAttendancesByTenant(
    tenantId: string,
    startDate?: Date,
    endDate?: Date
  ): Promise<Attendance[]> {
    return this.attendanceRepository.findByTenant(tenantId, startDate, endDate);
  }

  async deleteAttendance(id: string): Promise<void> {
    const attendance = await this.attendanceRepository.findById(id);
    if (!attendance) {
      throw new Error('Attendance not found');
    }

    await this.attendanceRepository.delete(id);
  }

  /**
   * Calculate working hours with backward compatibility
   */
  async calculateWorkingHours(attendanceId: string): Promise<{
    totalHours: number;
    effectiveHours: number;
    overtimeHours: number;
    lateMinutes: number;
    isFullDay: boolean;
    calculationMode: 'shift-based' | 'legacy';
  }> {
    const attendance = await this.attendanceRepository.findById(attendanceId);
    if (!attendance) {
      throw new Error('Attendance not found');
    }

    let shift = null;
    if (attendance.hasShift()) {
      shift = await this.shiftRepository.findById(attendance.shiftId!);
    }

    const calculation = AttendanceDomainService.calculateWorkingHours(attendance, shift ?? undefined);
    const calculationMode = AttendanceDomainService.getCalculationMode(attendance);

    return {
      ...calculation,
      calculationMode
    };
  }

  /**
   * Get attendance summary for a period with both calculation modes
   */
  async getAttendanceSummary(
    staffId: string,
    startDate: Date,
    endDate: Date
  ): Promise<{
    totalAttendances: number;
    shiftBasedAttendances: number;
    legacyAttendances: number;
    totalWorkingHours: number;
    totalOvertimeHours: number;
    totalLateMinutes: number;
    fullDays: number;
    attendances: Array<{
      attendance: Attendance;
      calculationMode: 'shift-based' | 'legacy';
      workingHours: number;
      overtimeHours: number;
      lateMinutes: number;
      isFullDay: boolean;
    }>;
  }> {
    const attendances = await this.attendanceRepository.findByStaff(staffId, startDate, endDate);
    
    let totalWorkingHours = 0;
    let totalOvertimeHours = 0;
    let totalLateMinutes = 0;
    let fullDays = 0;
    let shiftBasedCount = 0;
    let legacyCount = 0;

    const attendanceDetails = [];

    for (const attendance of attendances) {
      let shift = null;
      if (attendance.hasShift()) {
        shift = await this.shiftRepository.findById(attendance.shiftId!);
        shiftBasedCount++;
      } else {
        legacyCount++;
      }

      const calculation = AttendanceDomainService.calculateWorkingHours(attendance, shift ?? undefined);
      const calculationMode = AttendanceDomainService.getCalculationMode(attendance);

      totalWorkingHours += calculation.totalHours;
      totalOvertimeHours += calculation.overtimeHours;
      totalLateMinutes += calculation.lateMinutes;
      if (calculation.isFullDay) fullDays++;

      attendanceDetails.push({
        attendance,
        calculationMode,
        workingHours: calculation.totalHours,
        overtimeHours: calculation.overtimeHours,
        lateMinutes: calculation.lateMinutes,
        isFullDay: calculation.isFullDay
      });
    }

    return {
      totalAttendances: attendances.length,
      shiftBasedAttendances: shiftBasedCount,
      legacyAttendances: legacyCount,
      totalWorkingHours,
      totalOvertimeHours,
      totalLateMinutes,
      fullDays,
      attendances: attendanceDetails
    };
  }

  /**
   * Suggest shift for legacy attendance (migration helper)
   */
  async suggestShiftForAttendance(attendanceId: string): Promise<{
    suggestedShift: any | null;
    reason: string;
  }> {
    const attendance = await this.attendanceRepository.findById(attendanceId);
    if (!attendance) {
      throw new Error('Attendance not found');
    }

    if (attendance.hasShift()) {
      return {
        suggestedShift: null,
        reason: 'Attendance already has a shift assigned'
      };
    }

    if (!attendance.checkInTime) {
      return {
        suggestedShift: null,
        reason: 'Attendance has no check-in time to match against shifts'
      };
    }

    // Get all active shifts for the tenant
    const shifts = await this.shiftRepository.findByTenant(attendance.tenantId, true);
    const suggestedShift = AttendanceDomainService.suggestShiftForLegacyAttendance(attendance, shifts);

    if (!suggestedShift) {
      return {
        suggestedShift: null,
        reason: 'No suitable shift found for the check-in time'
      };
    }

    return {
      suggestedShift: {
        id: suggestedShift.id,
        name: suggestedShift.name,
        startTime: suggestedShift.startTime,
        endTime: suggestedShift.endTime
      },
      reason: `Suggested based on check-in time ${attendance.checkInTime} matching shift ${suggestedShift.name}`
    };
  }

  /**
   * Bulk update attendances to assign shifts (migration helper)
   */
  async bulkAssignShifts(
    assignments: Array<{
      attendanceId: string;
      shiftId: string;
    }>
  ): Promise<{
    successful: number;
    failed: Array<{
      attendanceId: string;
      error: string;
    }>;
  }> {
    let successful = 0;
    const failed = [];

    for (const assignment of assignments) {
      try {
        await this.updateAttendance(assignment.attendanceId, {
          shiftId: assignment.shiftId
        });
        successful++;
      } catch (error) {
        failed.push({
          attendanceId: assignment.attendanceId,
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    }

    return { successful, failed };
  }

  /**
   * Check-in functionality with shift support
   */
  async checkIn(
    tenantId: string,
    staffId: string,
    checkInTime: string,
    shiftId?: string
  ): Promise<Attendance> {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Check if already checked in today for this shift (or legacy attendance)
    const existingAttendances = await this.attendanceRepository.findByStaffAndDate(staffId, today);
    
    if (shiftId) {
      const existingShiftAttendance = existingAttendances.find(a => a.shiftId === shiftId);
      if (existingShiftAttendance?.checkInTime) {
        throw new Error('Already checked in for this shift today');
      }
    } else {
      const existingLegacyAttendance = existingAttendances.find(a => !a.hasShift());
      if (existingLegacyAttendance?.checkInTime) {
        throw new Error('Already checked in today (legacy mode)');
      }
    }

    // Create or update attendance
    const existingAttendance = shiftId 
      ? existingAttendances.find(a => a.shiftId === shiftId)
      : existingAttendances.find(a => !a.hasShift());

    if (existingAttendance) {
      return this.updateAttendance(existingAttendance.id, { checkInTime });
    } else {
      return this.createAttendance({
        tenantId,
        staffId,
        date: today,
        checkInTime,
        shiftId,
        isWeekend: today.getDay() === 0 || today.getDay() === 6
      });
    }
  }

  /**
   * Check-out functionality with shift support
   */
  async checkOut(
    tenantId: string,
    staffId: string,
    checkOutTime: string,
    shiftId?: string
  ): Promise<Attendance> {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const existingAttendances = await this.attendanceRepository.findByStaffAndDate(staffId, today);
    
    const targetAttendance = shiftId 
      ? existingAttendances.find(a => a.shiftId === shiftId)
      : existingAttendances.find(a => !a.hasShift());

    if (!targetAttendance) {
      throw new Error('No attendance record found for today');
    }

    if (!targetAttendance.checkInTime) {
      throw new Error('Cannot check out without checking in first');
    }

    if (targetAttendance.checkOutTime) {
      throw new Error('Already checked out');
    }

    return this.updateAttendance(targetAttendance.id, { checkOutTime });
  }
}